import ast
import csv
import json

import psycopg2

db_params = {
    'dbname': 'malware_db',
    'user': 'akash',
    'password': 'akash321',
    'host': 'localhost'
}
def extract_features(llm_text, truncation):
    features = {}
    lines = llm_text.split('\n')
    current_feature = None

    for line in lines:
        if line.startswith('Feature:'):
            current_feature = line.split('Feature:')[1].strip()
            features[current_feature] = None
        elif line.startswith('Raw data:') and current_feature:
            raw_data = line.split('Raw data:')[1].strip()

            if current_feature == 'Opcodes':
                # Handle 'Opcodes' feature with a limit of 3000 entries
                try:
                    opcodes = ast.literal_eval(raw_data)
                    # Ensure opcodes is a list, then slice if more than 3000 entries

                    opcodes = opcodes[:truncation]
                    features[current_feature] = opcodes
                except (ValueError, SyntaxError):
                    print(f"Error parsing Opcodes data: {raw_data}")
                    features[current_feature] = []
            elif current_feature == 'imports':
                    try:
                        imports_dict = ast.literal_eval(raw_data)
                        # Ensure imports_dict is a dict, then keep only the first 100 items
                        imports_limited = dict(list(imports_dict.items())[:50])
                        features[current_feature] = imports_limited
                    except (ValueError, SyntaxError):
                        print(f"Error parsing Imports data: {raw_data}")
                        features[current_feature] = {}

            elif current_feature == 'exports':
                try:
                    exports = ast.literal_eval(raw_data)
                    # Ensure opcodes is a list, then slice if more than 3000 entries

                    exports = exports[:50]
                    features[current_feature] = exports
                except (ValueError, SyntaxError):
                    print(f"Error parsing Exports data: {raw_data}")
                    features[current_feature] = {}


            elif current_feature == 'EntryPoint':
                try:
                    entryInfo = ast.literal_eval(raw_data)
                    # Ensure opcodes is a list, then slice if more than 3000 entries


                    entryInfo = entryInfo[:20]
                    features[current_feature] = entryInfo
                except (ValueError, SyntaxError):
                    print(f"Error parsing Imports data: {raw_data}")
                    features[current_feature] = []


            elif current_feature == 'ExitPoint':
                try:
                    exitInfo = ast.literal_eval(raw_data)
                    # Ensure opcodes is a list, then slice if more than 3000 entries


                    exitInfo = exitInfo[:20]
                    features[current_feature] = exitInfo
                except (ValueError, SyntaxError):
                    print(f"Error parsing Imports data: {raw_data}")
                    features[current_feature] = []


            elif current_feature == 'Opcode-Occurrence':
                # Handle defaultdict for Opcode-Occurrence feature
                opcode_dict_str = raw_data.replace("defaultdict(<class 'int'>, ", "").rstrip(')')

                try:
                    features[current_feature] = ast.literal_eval(opcode_dict_str)

                except (ValueError, SyntaxError):
                    print(f"Error parsing Opcode-Occurrence data: {opcode_dict_str}")
                    features[current_feature] = {}
            else:
                try:
                    # Converting string representation of list or dict to actual list or dict
                    features[current_feature] = ast.literal_eval(raw_data)
                except (ValueError, SyntaxError):
                    features[current_feature] = raw_data

    return features


def get_features_by_family(family_name):
    try:
        # Connect to your database
        conn = psycopg2.connect(**db_params)

        # Create a cursor object
        cur = conn.cursor()

        # Execute the query to fetch SHA and LLM text
        cur.execute("SELECT sha, llm_text FROM files WHERE family_name = %s", (family_name,))

        # Fetch all rows from the database
        records = cur.fetchall()

        # Close the cursor and connection
        cur.close()
        conn.close()

        feature_dicts = {}
        for sha, llm_text in records:
            if llm_text:
                dictio = extract_features(llm_text)
                feature_dicts[sha] = dictio

        return feature_dicts

    except Exception as e:
        print("Error in database operation:", e)
        return []

def get_features_by_sha(sha):
    # Assuming db_params is defined globally or passed to the function
    try:
        # Connect to your database
        conn = psycopg2.connect(**db_params)

        # Create a cursor object
        cur = conn.cursor()

        # Execute the query to fetch LLM text for a specific SHA
        cur.execute("SELECT llm_text FROM files WHERE sha = %s", (sha,))

        # Fetch the first row from the database
        record = cur.fetchone()

        # Close the cursor and connection
        cur.close()
        conn.close()

        if record:
            llm_text = record[0]
            if llm_text:
                # Assuming extract_features is a function that parses the llm_text into a dictionary of features
                features = extract_features(llm_text)
                return features
        return None
    except Exception as e:
        print("Error in database operation:", e)
        return None


def write_to_csv():
    # Connect to the database
    conn = psycopg2.connect(**db_params)
    cur = conn.cursor()

    # Open CSV file for writing
    with open('/malware.csv', mode='w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        # Write CSV header
        writer.writerow(['sha', 'llm_text', 'family_name'])
        # Execute the query
        cur.execute("SELECT sha, llm_text, family_name FROM files;")
        # Write each row to the CSV file
        for row in cur:
            writer.writerow(row)  # Write the row as received from the database

    # Cleanup
    cur.close()
    conn.close()

if __name__ == '__main__':
    write_to_csv()
    # get_features_by_family_from_csv('ABCbot', '../../malware.csv')
